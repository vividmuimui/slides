<section>

<h2>Acitve Record</h2>

<p>PoEAA - 10. Data Source Architectual Patterns</p>

<p><a href="https://github.com/vividmuimui" class="user-mention">@vividmuimui</a><br>
2017/08/24 PoEAA読書会資料</p>

</section>
<section>

<h2>Active Recordといえば</h2>

<p>RailsののActiveRecord。これも、このActiveRecordパターンを適用したもの。</p>

<p>「10. Data Source Architectual Patterns」には以下の4種類があるが、<br>
その中で一番シンプルなパターン。</p>

<ul>
  <li>Table Data Gateway</li>
  <li>Row Data Gateway</li>
  <li>Active Record</li>
  <li>Data Mapper</li>
</ul>

</section>
<section>

<h3 class="left">すごく雑に言うと</h3>

<ul>
  <li>DBのテーブル/ビューの1つのレコードを表現し、DBへのアクセスするロジック</li>
  <li>ドメインロジック</li>
</ul>

<p>この両方を１つのオブジェクトに詰め込んだパターンで、4つのパターンのうちとてもシンプルなパターン。</p>

<p><img src="https://www.martinfowler.com/eaaCatalog/activeRecordSketch.gif" alt=""><br>
(<a href="https://www.martinfowler.com/">https://www.martinfowler.com/</a> より)</p>

</section>
<section>

<h2>ほかのパータンはちょっと複雑</h2>

<p><img src="https://www.martinfowler.com/eaaCatalog/dbgateTable.gif" alt=""><br>
<img src="https://www.martinfowler.com/eaaCatalog/dbgateRow.gif" alt=""><br>
<img src="https://www.martinfowler.com/eaaCatalog/databaseMapperSketch.gif" alt=""><br>
(<a href="https://www.martinfowler.com/">https://www.martinfowler.com/</a> より)</p>

</section>
<section>

<h2>どのように動くか(How It Works) <img class="emoji" alt=":one:" src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png">
</h2>

<ul>
  <li>ActiveRecordは、DBのレコードに密接している</li>
  <li>ActiveRecordは、DBへの読み書きをする責任をもっていて、ドメインロジックも含んでいる</li>
  <li>ActiveRecordのデータ構造(各フィールド)は、DBの1つのレコードのカラムと一致する
    <ul>
      <li>nameカラムを持っていれば、ActiveRecordはnameフィールドを持つ</li>
    </ul>
  </li>
  <li>Foreign keyもそのまま使える</li>
  <li>ActiveRecordは、DBのテーブルだけでなくViewにも適用できるが、updateは困難なのでreadのみに使うのがよい</li>
</ul>

</section>
<section>

<h2>どのように動くか(How It Works) <img class="emoji" alt=":two:" src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png">
</h2>

<p>基本的には次のようなメソッドを持つ</p>

<ul>
  <li>selectのSQLの結果を用いてActiveRecordインスタンスを生成できる</li>
  <li>新しいActiveRecordインスタンスを生成してinsertが出来る</li>
  <li>検索のためのクラスメソッドがある
    <ul>
      <li>ActiveRecordのインスタンス(s)を返す</li>
    </ul>
  </li>
  <li>ActiveRecordのインスタンスのデータで、update, insertが出来る</li>
  <li>ActiveRecordの各フィールドのget, setが出来る</li>
  <li>ドメインロジック</li>
</ul>

</section>
<section>

<h2>どのように動くか(How It Works) <img class="emoji" alt=":three:" src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png">
</h2>

<p>このパターンは便利だが、DBが存在することを隠蔽できていない<br>
As a result you usually see fewer of the other object -relational mapping patterns present when you’re using ActiveRecord.</p>

<p>ActiveRecordは、<a href="https://www.martinfowler.com/eaaCatalog/rowDataGateway.html">RowDataGateway</a>パターンとよく似ている<br>
<a href="https://www.martinfowler.com/eaaCatalog/rowDataGateway.html">RowDataGateway</a>はデータベースアクセスしか持たないが、ActiveRecordはデータベースアクセスとドメインロジックを持っている</p>

<p>このパターンでは、find系のクラスメソッドが多くなる傾向にあるが、ほかクラスに分けてはいけないということはない<br>
ほかのパターンと併用しつつ、ActiveRecordはViewやQuery用に使うのも良い</p>

</section>
<section>

<h2>いつ使うのか(When to Use It) <img class="emoji" alt=":one:" src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png">
</h2>

<p>Active Recordは単なるCRUDするだけのようなドメインロジックが複雑すぎないケースではいい選択肢になる<br>
１つのレコードに対する、Derivations and validations(データの取得と検証?)がうまく出来る</p>

</section>
<section>

<h2>いつ使うのか(When to Use It) <img class="emoji" alt=":two:" src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png">
</h2>

<p><a href="https://www.martinfowler.com/eaaCatalog/domainModel.html">Domain Model</a>の設計時の主な選択肢として、<br>
ActiveRecordと<a href="https://www.martinfowler.com/eaaCatalog/dataMapper.html">DataMapper</a>があがるが、ActiveRecordはシンプルで理解しやすく作るのが簡単なのがメリット</p>

<p>ドメインロジックが複雑になってくると、relationships, collections, inheritanceなどがすぐに欲しくなるだろう<br>
それらをActiveRecordに適用するのは難易度が高いので、<a href="https://www.martinfowler.com/eaaCatalog/dataMapper.html">DataMapper</a>を使ったほうがよい</p>

</section>
<section>

<h2>いつ使うのか(When to Use It) <img class="emoji" alt=":three:" src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png">
</h2>

<p>ActiveRecordの短所の１つに、オブジェクトデザインとDBデザインが密結合しているため、プロジェクトの成長に合わせてリファクタしてくのが難しいという点がある</p>

</section>
<section>

<h2 class="center">サンプル通りに実装してみた</h2>

<p>javaのサンプルが本に載っているので、rubyで実装してみた<br>
(DBのコネクション部分はrailsのActiveRecordに頼っちゃいました <img class="emoji" alt=":stuck_out_tongue_closed_eyes:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png">)</p>

</section>
<section>

<h2>まずは準備 <img class="emoji" alt=":one:" src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png">
</h2>

<pre><code class="language-ruby"># Gemfile
source 'https://rubygems.org'

gem "activerecord"
gem "sqlite3"
</code></pre>

</section>
<section>

<h2>準備 <img class="emoji" alt=":two:" src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png">
</h2>

<pre><code class="language-ruby">require "active_record"

class CreatPeoples &lt; ActiveRecord::Migration[5.1]
  def change
    create_table :people do |t|
      t.string :lastname
      t.string :firstname
      t.integer :number_of_dependents
    end
  end
end

CreatPeoples.migrate(:up)
</code></pre>

<p><code>people</code>テーブルは、<br>
id, lastname, firstname, number_of_dependents<br>
の4つのカラムを持っている</p>

</section>
<section>

<h2>準備 <img class="emoji" alt=":three:" src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png">
</h2>

<pre><code class="language-ruby">ActiveRecord::Base.logger = Logger.new(STDOUT)
ActiveRecord::Base.establish_connection(
  adapter: "sqlite3",
  database: "demo.sqlite3"
)
</code></pre>

<p>sqliteにつなげるように設定する</p>

</section>
<section>

<h2 class="center">これで準備は完了</h2>

</section>
<section>

<h2>まずは .find の実装</h2>

<pre><code class="language-ruby">class People
  FIND_SQL = "SELECT id, lastname, firstname, number_of_dependents FROM people WHERE id = ?;"

  class &lt;&lt; self
    # キャッシュ周りのロジックは省略しました
    def find(id)
      # SQLをいい感じに組み立てて実行
      row_hash = con.select_one(ActiveRecord::Base.send(:sanitize_sql_array, [FIND_SQL, id]))
      new(row_hash.symbolize_keys) if row_hash # レコードが見つかったら自身のインスタンスを作成する
    end

    def con
      @con ||= ActiveRecord::Base.connection
    end
  end

  attr_accessor :id, :lastname, :firstname, :number_of_dependents

  def initialize(id: nil, lastname: nil, firstname: nil, number_of_dependents: nil)
    @id, @lastname, @firstname, @number_of_dependents = id, lastname, firstname, number_of_dependents
  end
end
</code></pre>

<p>実行してみると</p>

<pre><code>(main)&gt; People.find(1)
(0.2ms)  SELECT id, lastname, firstname, number_of_dependents FROM people WHERE id = 1;
=&gt; #&lt;People:0x007fa92b2adb00 @firstname="foo", @id=1, @lastname="bar", @number_of_dependents=100&gt;
</code></pre>

<p>動く <img class="emoji" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png"></p>

</section>
<section>

<h2>次は #update の実装</h2>

<pre><code class="language-ruby">class People
  UPDATE_SQL = "UPDATE people SET lastname = :lastname, firstname = :firstname, number_of_dependents = :number_of_dependents WHERE id = :id;"

  def update
    self.class.con.execute(ActiveRecord::Base.send(:sanitize_sql_array, [UPDATE_SQL, attributes]))
  end

  def attributes
    { id: id, firstname: firstname, lastname: lastname, number_of_dependents: number_of_dependents }
  end
end
</code></pre>

<p>クエリを組み立てて実行するだけ。実行してみると</p>

<pre><code>(main)&gt; people = People.find(1)
(0.2ms)  SELECT id, lastname, firstname, number_of_dependents FROM people WHERE id = 1;
=&gt; #&lt;People:0x007fa92a47efc0 @firstname="foo", @id=1, @lastname="bar", @number_of_dependents=100&gt;
// lastnameを書き換え
(main)&gt; people.lastname = "hoge"
=&gt; "hoge"

// update
(main)&gt; people.update
(0.8ms)  UPDATE people SET lastname = 'hoge', firstname = 'foo', number_of_dependents = 100 WHERE id = 1;
=&gt; []

// 取得し直してみるとlastnameが変わっているのがわかる
(main)&gt; People.find(1)
(0.2ms)  SELECT id, lastname, firstname, number_of_dependents FROM people WHERE id = 1;
=&gt; #&lt;People:0x007fa92d82a7e8 @firstname="foo", @id=1, @lastname="hoge", @number_of_dependents=100&gt;
</code></pre>

</section>
<section>

<h2>次は #insert の実装</h2>

<pre><code class="language-ruby">class People
  INSERT_SQL = "INSERT INTO people(id, lastname, firstname, number_of_dependents) VALUES (:id, :lastname, :firstname, :number_of_dependents);"

  def insert
    self.class.con.execute(ActiveRecord::Base.send(:sanitize_sql_array, [INSERT_SQL, attributes]))
  end
end
</code></pre>

<p>クエリを組み立てて実行するだけ。(保存済みかどうかみたいのは考慮してない)</p>

<p>実行してみると</p>

<pre><code>// newでインスタンスを作成
(main)&gt; people = People.new(id: 2, firstname: "hoge", lastname: "huga", number_of_dependents: 200)
=&gt; #&lt;People:0x007fa92b3d6590 @firstname="hoge", @id=2, @lastname="huga", @number_of_dependents=200&gt;

// insert
(main)&gt; people.insert
 (9.0ms)  INSERT INTO people(id, lastname, firstname, number_of_dependents) VALUES (2, 'huga', 'hoge', 200);
=&gt; []

// チートして用意した .all で確認すると、 レコードが増えていることがわかる
(main)&gt; People.all
People Load (0.2ms)  SELECT "people".* FROM "people"
=&gt; [#&lt;People:0x007fa92a6ab618 id: 1, lastname: "hoge", firstname: "foo", number_of_dependents: 100&gt;,
 #&lt;People:0x007fa92a698018 id: 2, lastname: "huga", firstname: "hoge", number_of_dependents: 200&gt;]
</code></pre>

</section>
<section>

<h2>ビジネスロジックを実装してみる</h2>

<pre><code class="language-ruby">class People
  def exemption
    base = 1500
    dependent = 750
    base + dependent * number_of_dependents
  end
end
</code></pre>

<p>本のサンプルがよく分かんなかったので、適当なメソッドを用意しました</p>

<p>実行してみると</p>

<pre><code>(main)&gt; People.find(1).exemption
(0.2ms)  SELECT id, lastname, firstname, number_of_dependents FROM people WHERE id = 1;
=&gt; 76500
(main)&gt; People.find(2).exemption
(0.1ms)  SELECT id, lastname, firstname, number_of_dependents FROM people WHERE id = 2;
=&gt; 151500
</code></pre>

</section>
<section>

<h2>終わり</h2>

<p>案外簡単にさくっとActiveRecordパターンを実装出来た <img class="emoji" alt=":tada:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png"><br>
(クエリビルダーとかコネクション周りでrailsのActiveRecord使ったけど。。)</p>

</section>
<section>

<h2>使ったコード</h2>

<pre><code class="language-ruby">require "active_record"

ActiveRecord::Base.logger = Logger.new(STDOUT)
ActiveRecord::Base.establish_connection(
  adapter: "sqlite3",
  database: "demo.sqlite3"
)

class Registory
  class &lt;&lt; self
    def person(id) ;end
    def add_person(person); end
  end
end

class People
  FIND_SQL = "SELECT id, lastname, firstname, number_of_dependents FROM people WHERE id = ?;"
  UPDATE_SQL = "UPDATE people SET lastname = :lastname, firstname = :firstname, number_of_dependents = :number_of_dependents WHERE id = :id;"
  INSERT_SQL = "INSERT INTO people(id, lastname, firstname, number_of_dependents) VALUES (:id, :lastname, :firstname, :number_of_dependents);"

  class &lt;&lt; self
    # キャッシュ周りのロジックは省略しました
    def find(id)
      # SQLをいい感じに組み立てて実行
      row_hash = con.select_one(ActiveRecord::Base.send(:sanitize_sql_array, [FIND_SQL, id]))
      new(row_hash.symbolize_keys) if row_hash # レコードが見つかったら自身のインスタンスを作成する
    end

    def con
      @con ||= ActiveRecord::Base.connection
    end
  end

  attr_accessor :id, :lastname, :firstname, :number_of_dependents

  def initialize(id: nil, lastname: nil, firstname: nil, number_of_dependents: nil)
    @id, @lastname, @firstname, @number_of_dependents = id, lastname, firstname, number_of_dependents
  end

  def update
    self.class.con.execute(ActiveRecord::Base.send(:sanitize_sql_array, [UPDATE_SQL, attributes]))
  end

  def insert
    self.class.con.execute(ActiveRecord::Base.send(:sanitize_sql_array, [INSERT_SQL, attributes]))
  end

  def exemption
    base = 1500
    dependent = 750
    base + dependent * number_of_dependents
  end

  def attributes
    {
      id: id,
      firstname: firstname,
      lastname: lastname,
      number_of_dependents: number_of_dependents
    }
  end
end

ActiveRecord::Base.connection.execute("drop table people;") rescue nil

class CreatPeoples &lt; ActiveRecord::Migration[5.1]
  def change
    create_table :people do |t|
      t.string :lastname
      t.string :firstname
      t.integer :number_of_dependents
    end
  end
end

CreatPeoples.migrate(:up)

# 初期データを用意
People.new(id: 1, firstname: "foo", lastname: "bar", number_of_dependents: 100).insert

# select
people = People.find(1)

# update
people = People.find(1)
people.lastname = "hoge"
people.update
People.find(1)

# insert
people = People.new(id: 2, firstname: "hoge", lastname: "huga", number_of_dependents: 200)
people.insert
class CheatPeople &lt; ActiveRecord::Base
  self.table_name = "people"
end
CheatPeople.all

# ビジネスロジック
People.find(1).exemption
People.find(2).exemption
</code></pre>

</section>
